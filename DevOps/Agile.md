Comes from parallel innovation (Scrum, XP)
Light weight development model. 
Best suited for smaller and medium sized business systems - Can it be scaled??

Principles > Process - Lots of meetings. 

**Limiting works in progress**
- Software > Docs
- Apply time limits (Scrum) || Limit the amount of work in progress (Kanban). 
- Allows for more frequent learning, less redundant projects.

**Collaboration**
- Social dimension
- Cross-functional teams (Team with all different skills needed, not niche)
- Product trio (Dev, Designer, Product Manager)
- Roles and responsibilities can get muddled up. 

**Refinement**
- Make responding to change as part of your plan. 

**Principles, Practices and Outcomes**
1. Focus with working software than documentation - Working software
2. Focus on customer collaboration over contract negotiation - Customer Collaboration
3. Focus on responding to changes over following a plan - Responding to change
4. Individuals and interactions  

!! What are you doing? Why are you doing it? What do you want to achieve? is it working?

**Practices**
- Sprints and iterations - Cycle of finishing and releasing work as things are completed. 
- Standup and Status Meetings - What did you do yesterday? will do today? What is blocking your progress?
- Retrospectives - Evaluation of what went well, and what could be improved. 

SCRUM:
- Process tool, split organisaTion in small cross functional teams. 
- Split work in small and concrete deliverables. 
- Do short iterations of 1 to 4 weeks. 
- Optimise process by having retrospective after each iteration. 

Kanban:

Pert Chart - Units (Time) taken to achieve a goal.


**Extreme Programming:**
Still has planning and design phases that focus on coding and testing. 
Overall process is iterative and incremental. 
User story:
- Each story is up to 3 sentences long, written by customer with priority value. 
- If story takes more than 3 weeks then it's too big and needs to be split
- Stories can be added, modified and deleted. 
Only Class responsibility collaboration cards are used (CRC). 
Write code after the unit test
Pair programming. 
Code is continuously integrated with existing code via TDD.
Easier to make changes with TDD and refactoring
TDD:
- Run all tests again to avoid regression to preserver system behaviour 
- Relies on repetition of short dev cycle, Add test > run tests and see if new fails > Write code> Run test > Refactor code > repeat. 

*Criticisms*
- Rejects proven engineering techniques. 
- Lacks documentation. 
- Lacks formal design - No complex diagrams and specifications
- Complicates contract negotiations. 

**Advantages**
- Best practices found in dev envs. 
- Risks in a project should be reduced as output of devs is reviewed early and constantly during dev. 
- New projects need creativity, where new requirements might be needed. 
- Flexibility can be higher than traditional methods. 
- Encourages a lot of communications between devs and those who will use it. 
- Reduces silos in project teams 
- Results in a lot less re work on projects as issues as changes should be picked up earlier. 
- Collaboration is a lot higher with Agile, resulting in more successful dev envs. 
- Common use of visuals to easily see what is going on. 

**Drawbacks**
- Hard to do in practice
- Less predictable to know what is delivered at the end. 
- High levels of collaboration and comms between devs and users. 
- Very intensive for devs and users. May prevent work. 
- Less of a blueprint for what the final deliverable will be. Harder to get commitment to project by stakeholders. 
- Challenging for supplier customer relationship. 
- Reluctance to adopt or accept deadlines. 
- Dealing with lead times and major dependencies. 