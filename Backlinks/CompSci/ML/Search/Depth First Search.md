Expands the deepest node in the frontier first

Uses a Stack structure LIFO.

Usually implemented as a tree like search which does not keep a table of reached states.

It is not cost optimal, and will return the first solution it finds, regardless of cost.

Efficient and complete in finite state spaces.

For acyclic state spaces it might expand the same state many time, but will eventually explore all the states

For cyclic state spaces it can get stuck in an infinite loop.

In infinite state spaces it is not systematic, can get stuck in an infinite path

Benefits are that it does not need a lot of memory - No reached table and small frontier.

In finite tree shaped state space, it takes time proportional to the number of states O(bm) b is the branching factor and m is the depth of the tree.

### Backtracking search:

Variant that uses even less memory

Generates one successor at the time, and they are generated by modifying current state description directly, instead of allocating new memory for it. O(m)

Can also keep a set data structure for the states on current path, allowing to check for cyclic path in O(1) time.

For backtracking to work we need to be able to undo each action.

Used in a lot of problems with large state descriptions like robotic assembly.